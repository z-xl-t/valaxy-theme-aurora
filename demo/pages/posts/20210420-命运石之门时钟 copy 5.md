---
title: "[WPF] 命运石之门时钟3.3"
tags: [CSharp, 命运石之门,CSharp, 命运石之门]
categories: [笔记本,第二分类,第三分类]
imageUrl: 'https://i.loli.net/2020/06/30/iGW3CIPSUZas4Yx.jpg'
imageSource: ''
description: '这一切都是命运石之门的选择'
comments: true
date: 2021-04-21 23:37:09
---

## 太长不看版

```

GitHub:(https://github.com/sanshiliuxiao/DivergenceMeter)


```
 imgBox 0.gif 软件运行效果 

### 更新内容

重新使用 `Prsim` 框架进行重写，更优雅的实现。

完整视频链接： [WPF命运石之门效果时钟教程](https://www.bilibili.com/video/BV1qy4y1n7xE)


## 正文

去年，还写过 web 版的 时钟挂件，今年因为学了点 `C#`，索性又学了点 `WPF`，经过一段时间的折腾终于是把这个时钟挂件给写完了。

本文记录这个时钟挂件源代码的代码片段。我没有用 MVVM 模式开发，所有一切的操作，都是基于事件即发生了什么事件，触发某样动作或者进行某些设置。基于事件的工作流程好处就是简单易懂，坏处是写着写着代码就乱成一团了，但是有一句话说的好：**又不是不能用！**


### 异性窗体

异性窗体一般就是指 无边框的透明窗体，主要就是设置`WindowStyle`、 `ResizeMode ` 和 `AllwosTransparency` 属性。 设置完毕后，会发现窗体不能移动了，这个时候需要对 window 的 鼠标事件进行监听，这里 我选择的是 鼠标左键按下去 的事件 `MouseLeftButtonDown`，调用 `DragMove` 函数。

```
// MainWindow.xaml

<Window WindowStyle="None" ResizeMode="NoResize" AllowsTransparency="True" MouseLeftButtonDown="Window_MouseLeftButtonDown" ></Window>

// MainWindow.xaml.cs

private void Window_MouseLeftButtonDown(object sender, MouseButtonEventArgs e)
   DragMove();
}

```
### 点击穿透

这个功能实现起来花的时间最久，在网上找了很多文章，最终才实现这个理想中的效果。

最开始我是设置 `IsHitTestVisible ` 属性去实现这个效果，网络上很多文章，也是这样告诉我的，可是效果确实不怎么样。

```
// MainWindow.xaml

<Window IsHitTestVisible="False" /></Window>
```

发现实现效果不怎么样之后，去 GitHub 上 提 [Issues](https://github.com/dotnet/wpf/issues/3088) 得到关键字 `WS_EX_TRANSPARENT`，之后又找了很多资料，才实现这个功能。主要是使用 `user32.dll` 这个库， 一般 Windows 系统都内置 `user32.dll` 文件。

**注意： 点击穿透功能和运行拖拽功能是互斥的，因为不可能又穿透，又能拖拽啊！！！**

 imgBox 1.gif IsHitTestVisible 效果 
 imgBox 2.gif 期望效果 


```
// MainWindow.xaml
<!-- IsHitTestVisible="False" -->

// MainWindow.xaml.cs

// use32.dll 引入 所需要的函数
#region Window styles
[DllImport("user32.dll")]
public static extern int GetWindowLong(IntPtr hwnd, int index);

[Flags]
public enum ExtendedWindowStyles
{
    WS_EX_TOOLWINDOW = 0x00000080,
    WS_EX_LAYERED = 0x80000,
    WS_EX_TRANSPARENT = 0x00000020
}
[Flags]
public enum GetWindowLongFields
{
    GWL_EXSTYLE = (-20),
}
[DllImport("user32.dll")]
public static extern int SetWindowLong(IntPtr hwnd, int index, int newStyle);

public static IntPtr SetWindowLong(IntPtr hWnd, int nIndex, IntPtr dwNewLong)
{
    int error = 0;
    IntPtr result = IntPtr.Zero;
    // Win32 SetWindowLong doesn't clear error on success
    SetLastError(0);

    if (IntPtr.Size == 4)
    {
        // use SetWindowLong
        Int32 tempResult = IntSetWindowLong(hWnd, nIndex, IntPtrToInt32(dwNewLong));
        error = Marshal.GetLastWin32Error();
        result = new IntPtr(tempResult);
    }
    else
    {
        // use SetWindowLongPtr
        result = IntSetWindowLongPtr(hWnd, nIndex, dwNewLong);
        error = Marshal.GetLastWin32Error();
    }

    if ((result == IntPtr.Zero) && (error != 0))
    {
        throw new System.ComponentModel.Win32Exception(error);
    }

    return result;
}

[DllImport("user32.dll", EntryPoint = "SetWindowLongPtr", SetLastError = true)]
private static extern IntPtr IntSetWindowLongPtr(IntPtr hWnd, int nIndex, IntPtr dwNewLong);

[DllImport("user32.dll", EntryPoint = "SetWindowLong", SetLastError = true)]
private static extern Int32 IntSetWindowLong(IntPtr hWnd, int nIndex, Int32 dwNewLong);

private static int IntPtrToInt32(IntPtr intPtr)
{
    return unchecked((int)intPtr.ToInt64());
}

[DllImport("kernel32.dll", EntryPoint = "SetLastError")]
public static extern void SetLastError(int dwErrorCode);
#endregion

// 如果要在应用一启动，就设置该效果，需要重写 OnSourceInitialized 函数
// 只有在 OnSourceInitialized 函数触发之后，才能获取到 Windows 句柄
protected override void OnSourceInitialized(EventArgs e)
{
    // 从设置文件里面读取 bool 值
    ClickWindowAndNotMouseEvent(flag);
}

public void ClickWindowAndNotMouseEvent(bool flag)
{
    // Get this window's handle
    IntPtr hwnd = new WindowInteropHelper(this).Handle;
    if (flag)
    {
        SetWindowLong(hwnd, (int)GetWindowLongFields.GWL_EXSTYLE, (int)ExtendedWindowStyles.WS_EX_TRANSPARENT);
    } else
    {
        SetWindowLong(hwnd, (int)GetWindowLongFields.GWL_EXSTYLE, (int)ExtendedWindowStyles.WS_EX_LAYERED);
    }

}


```


### 系统托盘

这个功能分三点：
1. 隐藏任务栏的图标
2. 当 Win + Tab 时不显示该应用界面
3. 显示系统托盘图标

隐藏任务栏的图标，只需要设置 `ShowInTaskbar` 属性
```
// MainWindow.xaml
<Window ShowInTaskbar="False"></Window>
```

当 Win + tab 切换时，不应该显示应用界面，这里同样借用了 `user32.dll` 的函数实现

```
// MainWindow.xaml.cs
protected override void OnSourceInitialized(EventArgs e)
{
    
    HiddenTheAppInToolWindow();
}
private void HiddenTheAppInToolWindow()
{
    WindowInteropHelper wndHelper = new WindowInteropHelper(this);
    int exStyle = (int)GetWindowLong(wndHelper.Handle, (int)GetWindowLongFields.GWL_EXSTYLE);
    exStyle = exStyle | (int)ExtendedWindowStyles.WS_EX_TOOLWINDOW;
    SetWindowLong(wndHelper.Handle, (int)GetWindowLongFields.GWL_EXSTYLE, (IntPtr)exStyle);
}

```

实现系统托盘功能，是使用的 `Hardcodet.NotifyIcon.Wpf` 第三方库，简单易用。

### 开机自启功能

需要往注册表里面添加对应的程序名和程序路径

```
private void StartWhenSystemStart(bool flag)
{
    String programName = "DivergenceMeter";
    String programPath = Process.GetCurrentProcess().MainModule.FileName;
    RegistryKey reg = Registry.CurrentUser.OpenSubKey("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run", true);
    
    if (flag)
    {
        reg.SetValue(programName, programPath);
    }
    else
    {
        reg.DeleteValue(programName, false);
    }
}
```


## 文章更新

### TextBox 无法绑定 `double` 数据类型

```csharp
public App()
{
// 在 .NET 4.5 以上， TextBox 无法输入 浮动数 需要做如下修改

FrameworkCompatibilityPreferences.KeepTextBoxDisplaySynchronizedWithTextProperty = false;
}
```


### 窗口句柄的获取


窗口从初始化到显示出来，是按照顺序一步一步进行的，窗体的 `DataContext` 的挂载会在较前的位置，之后才会执行 `OnSourceInitialized` 函数，因此，可以获取到 `vm` 中的方法，并且去执行。


```csharp
protected override void OnSourceInitialized(EventArgs e)
{
    base.OnSourceInitialized(e);
    // 重写此函数，得到 Handle
    // 获取 vm
    var vm = this.DataContext as MainWindowViewModel;

    var window = Window.GetWindow(this);
    if (window == null) return;

    // 获取 句柄
    var handle = new WindowInteropHelper(window).Handle;

    if (handle != IntPtr.Zero)
    {
        // 执行一些操作
        
        vm.SetTheClickThrough(handle);

        vm.HiddenWindowTaskbar(handle);
    }

    // 开启启动实现：往开机启动文件夹里写入快捷方式（无需管理员权限）
    vm.SetStartup();
}
```

### PInvoke.User32

官方开源 PInvoke 库 包含大量 win32 封装，之前需要自行导入 `User32` 的对应函数，现在也不需要了，可以很方便的实现之前的点击穿透等功能

#### 点击穿透

```csharp
private void SetTheClickThrough(bool canClickThrough)
{
    if (_mainWindowHandle == IntPtr.Zero) return;
    // 函数重载
    if (canClickThrough)
    {
        // 设置穿透效果
        User32.SetWindowLong(_mainWindowHandle, User32.WindowLongIndexFlags.GWL_EXSTYLE, User32.SetWindowLongFlags.WS_EX_TRANSPARENT);
    }
    else
    {
        // 回复到正常效果
        User32.SetWindowLong(_mainWindowHandle, User32.WindowLongIndexFlags.GWL_EXSTYLE, User32.SetWindowLongFlags.WS_EX_LAYERED);
    }
}
```

### 开机自启

之前的开机自启功能是需要管理员权限，因此可能会执行不成功，而采用快捷方式的方式，则无需管理员权限，只需将快捷方式，放入 `Windows` 的开机启动文件夹下即可。

```csharp
private void SetStartup(bool canStartup)
{
    string startupPath = Environment.GetFolderPath(Environment.SpecialFolder.Startup);
    var appPath = Process.GetCurrentProcess().MainModule.FileName;
    var workPath = AppDomain.CurrentDomain.SetupInformation.ApplicationBase;

    var shortcutName = System.IO.Path.GetFileNameWithoutExtension(appPath);

    var linkPath = $@"{startupPath}\{shortcutName}.lnk";

    if (canStartup)
    {
        if (!File.Exists(linkPath))
        {
            var shellType = Type.GetTypeFromProgID("WScript.shell");
            dynamic shell = Activator.CreateInstance(shellType);
            var shortcut = shell.CreateShortcut(linkPath);
            shortcut.TargetPath = appPath;
            shortcut.WorkingDirectory = workPath;
            shortcut.Save();

        }
    }

    else
    {
        if (File.Exists(linkPath))
        {
            File.Delete(linkPath);
        }
    }

}

```


![test](https://i.loli.net/2020/06/30/iGW3CIPSUZas4Yx.jpg)